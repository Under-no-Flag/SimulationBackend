# 仿真启动流程梳理

## 概述

本文档详细说明了重新梳理后的仿真启动流程，确保参数设置和数据库保存的逻辑清晰，避免混乱。

## 整体流程

```
HTTP请求 -> Controller -> Service -> 数据库保存 -> 参数应用 -> 仿真运行
```

## 详细流程

### 1. Controller层 (SimulationController.java)

**接收请求**
- 接收包含 `engineParameters` 和 `agentParameters` 的 HTTP POST 请求
- 参数格式：`Map<String, Object>`

**参数验证**
- 检查模型文件是否存在
- 记录接收到的参数数量

**调用服务**
- 直接传递 `Map<String, Object>` 参数到服务层
- 不进行JSON转换（转换在服务层处理）

### 2. Service层 (AnyLogicModelService.java)

#### 2.1 createAndStartSimulation 方法

**参数处理**
```java
// 将Map参数转换为JSON字符串
String engineParametersJson = objectMapper.writeValueAsString(engineParameters);
String agentParametersJson = objectMapper.writeValueAsString(agentParameters);
```

**数据库保存**
```java
// 创建仿真运行记录
SimulationRun simulationRun = new SimulationRun();
simulationRun.setModelName(modelName);
simulationRun.setStartDate(LocalDateTime.now());
simulationRun.setState(Experiment.State.IDLE);
simulationRun.setEngineParameters(engineParametersJson);  // 保存引擎参数JSON
simulationRun.setAgentParameters(agentParametersJson);    // 保存智能体参数JSON
simulationRun.setDescription(description);
simulationRun = simulationRunRepository.save(simulationRun);
```

**异步启动**
- 调用 `startSimulationAsync(runId)` 异步启动仿真
- 更新状态为 `RUNNING`

#### 2.2 runSimulationInThread 方法

**参数获取**
```java
// 从数据库获取保存的参数
SimulationRun simulationRun = simulationRunRepository.findById(runId).orElse(null);
String engineParametersJson = simulationRun.getEngineParameters();
String agentParametersJson = simulationRun.getAgentParameters();
```

**仿真实例创建**
```java
// 创建仿真实例
Simulation experiment = new Simulation();
activeExperiments.put(runId, experiment);
```

**参数应用流程**
```java
// 1. 应用引擎参数（在创建智能体之前）
applyEngineParameters(experiment, engineParametersJson);

// 2. 创建顶层智能体
experiment.step();

// 3. 应用智能体参数（在智能体创建之后）
applyAgentParameters(experiment, agentParametersJson);
```

**仿真运行**
```java
// 启动无界面仿真
runHeadlessSimulation(experiment, runId);
```

### 3. 参数应用层

#### 3.1 applyEngineParameters 方法

**功能**
- 在创建智能体之前应用引擎级别的参数
- 通过反射设置引擎对象的字段或调用setter方法

**流程**
```java
// 1. 解析JSON参数
Map<String, Object> parameters = objectMapper.readValue(engineParametersJson, Map.class);

// 2. 获取引擎对象
Object engine = experiment.getEngine();

// 3. 应用每个参数
for (Map.Entry<String, Object> entry : parameters.entrySet()) {
    setEngineParameterValue(engine, paramName, paramValue);
}
```

#### 3.2 applyAgentParameters 方法

**功能**
- 在智能体创建之后应用智能体级别的参数
- 通过反射设置智能体对象的字段或调用setter方法

**流程**
```java
// 1. 解析JSON参数
Map<String, Object> parameters = objectMapper.readValue(agentParametersJson, Map.class);

// 2. 获取主智能体对象
Object mainAgent = getMainAgent(experiment);

// 3. 应用每个参数
for (Map.Entry<String, Object> entry : parameters.entrySet()) {
    setParameterValue(mainAgent, paramName, paramValue);
}
```

### 4. 数据库结构

**simulation_runs 表**
```sql
CREATE TABLE simulation_runs (
    run_id INT PRIMARY KEY AUTO_INCREMENT,
    model_name VARCHAR(255),
    start_date DATETIME,
    end_date DATETIME,
    status VARCHAR(50),
    engine_parameters TEXT,    -- 引擎参数JSON字符串
    agent_parameters TEXT,     -- 智能体参数JSON字符串
    description TEXT,
    port INT
);
```

## 关键改进

### 1. 参数处理清晰化
- **Controller层**：只负责接收和验证参数，不进行JSON转换
- **Service层**：负责参数转换、数据库保存和参数应用
- **参数应用层**：专门负责通过反射设置参数

### 2. 数据库保存时机
- 参数在 `createAndStartSimulation` 方法中转换为JSON并保存
- 在 `runSimulationInThread` 方法中从数据库读取参数
- 确保参数在整个仿真生命周期中保持一致

### 3. 参数应用时机
- **引擎参数**：在创建智能体之前应用
- **智能体参数**：在智能体创建之后应用
- 避免参数应用时机混乱

### 4. 错误处理
- 每个步骤都有详细的日志记录
- 参数应用失败不会影响整个仿真流程
- 异常处理确保后端服务稳定运行

## 使用示例

### API请求
```json
POST /api/simulation/start
{
    "modelName": "NanJingDong",
    "engineParameters": {
        "startDate": "2025-05-31 15:30:00",
        "stopDate": "2025-05-31 16:40:00",
        "realTimeScale": 1000
    },
    "agentParameters": {
        "simulTargetTime": "2025-05-31 15:30:00"
    },
    "description": "测试仿真"
}
```

### 参数应用流程
1. **引擎参数应用**：
   - `engine.setStartDate(startDate)`
   - `engine.setStopDate(stopDate)`
   - `engine.setRealTimeScale(1000)`

2. **智能体参数应用**：
   - `mainAgent.setParameter("simulTargetTime", "2025-05-31 15:30:00", true)`

## 总结

重新梳理后的仿真启动流程具有以下特点：

1. **职责分离**：每个层次都有明确的职责
2. **参数清晰**：引擎参数和智能体参数分别处理
3. **时机正确**：参数应用时机符合AnyLogic模型的要求
4. **错误容错**：完善的错误处理机制
5. **日志完整**：详细的日志记录便于调试

这样的设计确保了仿真启动流程的稳定性和可维护性。
