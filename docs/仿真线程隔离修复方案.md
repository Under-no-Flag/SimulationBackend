# 仿真线程隔离修复方案

## 问题描述

当外部关闭仿真模型线程时，后端服务也会停止运行。这是一个严重的稳定性问题，影响服务的可用性。

## 问题原因分析

### 1. 线程耦合问题
- AnyLogic仿真引擎可能创建非守护线程，与主JVM进程绑定
- 仿真线程异常时可能影响主应用程序线程

### 2. 异常传播问题
- 仿真线程中的未处理异常可能传播到主线程
- RuntimeException抛出导致应用程序终止

### 3. 资源清理不完整
- 仿真被强制关闭时，没有正确清理资源
- 线程池管理不当，导致JVM无法正常退出

### 4. JVM关闭机制
- AnyLogic可能触发JVM的关闭钩子
- 缺乏应用程序级别的资源保护机制

## 修复方案

### 1. 线程隔离机制 ✅

#### 守护线程池
```java
// 使用守护线程防止JVM关闭
private final ExecutorService simulationExecutor = Executors.newFixedThreadPool(5, new ThreadFactory() {
    private final AtomicInteger threadNumber = new AtomicInteger(1);
    
    @Override
    public Thread newThread(Runnable r) {
        Thread t = new Thread(r, "SimulationWorker-" + threadNumber.getAndIncrement());
        t.setDaemon(true); // 设置为守护线程
        t.setUncaughtExceptionHandler((thread, exception) -> {
            logger.error("仿真线程 {} 发生未捕获异常: {}", thread.getName(), exception.getMessage(), exception);
            // 不让异常传播到主线程
        });
        return t;
    }
});
```

**优势**:
- 守护线程不会阻止JVM退出
- 未捕获异常处理器防止异常传播
- 独立的线程命名便于问题追踪

#### 异常隔离
```java
// 不抛出RuntimeException，避免影响主应用程序
} catch (Exception e) {
    logger.error("仿真线程执行失败 run_id={}: {}", runId, e.getMessage(), e);
    updateSimulationState(runId, Experiment.State.ERROR);
    
    logger.error("仿真执行失败，但不影响后端服务继续运行 run_id={}", runId);
    return null; // 返回null表示失败，但不中断应用程序
}
```

### 2. 增强异常处理 ✅

#### 多层异常处理
```java
// 在隔离的线程中启动仿真
CompletableFuture<Void> simulationRunFuture = CompletableFuture.runAsync(() -> {
    Thread currentThread = Thread.currentThread();
    String originalName = currentThread.getName();
    currentThread.setName("Simulation-" + runId);
    
    try {
        // 设置线程中断处理
        if (Thread.currentThread().isInterrupted()) {
            logger.warn("仿真线程被中断，停止运行 run_id={}", runId);
            return;
        }
        
        experiment.run();
        logger.info("仿真正常结束 run_id={}", runId);
        
    } catch (Exception e) {
        logger.error("仿真运行异常 run_id={}: {}", runId, e.getMessage(), e);
        updateSimulationState(runId, Experiment.State.ERROR);
    } finally {
        currentThread.setName(originalName);
        logger.info("仿真线程清理完成 run_id={}", runId);
    }
}, simulationExecutor).exceptionally(throwable -> {
    logger.error("仿真执行出现严重错误 run_id={}: {}", runId, throwable.getMessage(), throwable);
    updateSimulationState(runId, Experiment.State.ERROR);
    return null;
});
```

#### 状态监控改进
```java
// 监控仿真状态 - 改进版本，支持早期退出和异常恢复
boolean simulationCompleted = false;
for (int i = 0; i < 12 && !simulationCompleted; i++) {
    try {
        // 检查当前线程是否被中断
        if (Thread.currentThread().isInterrupted()) {
            logger.warn("监控线程被中断，停止监控 run_id={}", runId);
            break;
        }
        
        // 检查仿真是否已经完成
        if (simulationRunFuture.isDone()) {
            logger.info("仿真执行已完成 run_id={}", runId);
            simulationCompleted = true;
            break;
        }
        
        // 安全的状态检查和日志记录
        
    } catch (Exception e) {
        logger.error("监控过程中发生异常 run_id={}: {}", runId, e.getMessage(), e);
        // 继续监控，不因单次异常而停止
    }
}
```

### 3. 资源管理优化 ✅

#### JVM关闭钩子
```java
// 注册JVM关闭钩子，确保在应用程序关闭时清理仿真资源
Runtime.getRuntime().addShutdownHook(new Thread(() -> {
    logger.info("应用程序关闭，开始清理仿真资源...");
    shutdownGracefully();
}, "SimulationCleanupHook"));
```

#### 优雅关闭机制
```java
public void shutdownGracefully() {
    logger.info("开始优雅关闭仿真服务...");
    
    try {
        // 停止所有运行中的仿真
        for (Integer runId : new java.util.ArrayList<>(runningSimulations.keySet())) {
            try {
                logger.info("正在停止仿真 run_id={}", runId);
                stopSimulation(runId);
            } catch (Exception e) {
                logger.error("停止仿真失败 run_id={}: {}", runId, e.getMessage());
            }
        }
        
        // 关闭线程池
        simulationExecutor.shutdown();
        if (!simulationExecutor.awaitTermination(30, TimeUnit.SECONDS)) {
            logger.warn("仿真线程池未能在30秒内优雅关闭，强制关闭");
            simulationExecutor.shutdownNow();
        }
        
        // 清理资源
        runningSimulations.clear();
        activeExperiments.clear();
        
    } catch (Exception e) {
        logger.error("优雅关闭仿真服务时发生异常: {}", e.getMessage(), e);
    }
}
```

#### 改进的停止方法
```java
public boolean stopSimulation(Integer runId) {
    try {
        CompletableFuture<Void> task = runningSimulations.get(runId);
        Object experiment = activeExperiments.get(runId);
        
        boolean stopped = false;
        
        // 尝试停止CompletableFuture任务
        if (task != null) {
            boolean cancelled = task.cancel(true);
            if (cancelled) {
                logger.info("成功取消仿真任务 run_id={}", runId);
                stopped = true;
            }
        }
        
        // 尝试停止AnyLogic实验
        if (experiment != null) {
            try {
                Method stopMethod = experiment.getClass().getMethod("stop");
                stopMethod.invoke(experiment);
                logger.info("成功调用实验停止方法 run_id={}", runId);
                stopped = true;
            } catch (Exception e) {
                logger.debug("无法调用实验停止方法 run_id={}: {}", runId, e.getMessage());
            }
        }
        
        // 清理资源
        runningSimulations.remove(runId);
        activeExperiments.remove(runId);
        
        if (stopped) {
            updateSimulationState(runId, Experiment.State.IDLE);
            return true;
        }
        
    } catch (Exception e) {
        logger.error("停止仿真时发生异常 run_id={}: {}", runId, e.getMessage(), e);
        // 即使发生异常，也要清理资源
        runningSimulations.remove(runId);
        activeExperiments.remove(runId);
    }
    
    return false;
}
```

### 4. 健康监控机制 ✅

#### 服务健康检查
```java
public Map<String, Object> getServiceHealthStatus() {
    Map<String, Object> status = new HashMap<>();
    
    try {
        status.put("isHealthy", true);
        status.put("runningSimulations", runningSimulations.size());
        status.put("activeExperiments", activeExperiments.size());
        status.put("threadPoolActive", !simulationExecutor.isShutdown());
        status.put("threadPoolTerminated", simulationExecutor.isTerminated());
        
        // 检查每个运行中的仿真状态
        Map<String, String> simulationStatuses = new HashMap<>();
        for (Map.Entry<Integer, CompletableFuture<Void>> entry : runningSimulations.entrySet()) {
            Integer runId = entry.getKey();
            CompletableFuture<Void> future = entry.getValue();
            
            if (future.isDone()) {
                if (future.isCompletedExceptionally()) {
                    simulationStatuses.put(runId.toString(), "FAILED");
                } else {
                    simulationStatuses.put(runId.toString(), "COMPLETED");
                }
            } else if (future.isCancelled()) {
                simulationStatuses.put(runId.toString(), "CANCELLED");
            } else {
                simulationStatuses.put(runId.toString(), "RUNNING");
            }
        }
        status.put("simulationDetails", simulationStatuses);
        
    } catch (Exception e) {
        status.put("isHealthy", false);
        status.put("error", e.getMessage());
    }
    
    return status;
}
```

#### 健康检查接口
```java
@GetMapping("/health")
public ResponseEntity<?> getServiceHealth() {
    try {
        Map<String, Object> healthStatus = anyLogicModelService.getServiceHealthStatus();
        boolean isHealthy = (Boolean) healthStatus.getOrDefault("isHealthy", false);
        
        if (isHealthy) {
            return ResponseEntity.ok(new ApiResponse(true, "服务健康", healthStatus));
        } else {
            return ResponseEntity.status(503)
                .body(new ApiResponse(false, "服务不健康", healthStatus));
        }
    } catch (Exception e) {
        return ResponseEntity.status(503)
            .body(new ApiResponse(false, "健康检查失败: " + e.getMessage(), null));
    }
}
```

## 修复效果

### 1. 线程隔离 ✅
- ✅ 仿真线程异常不再影响主应用程序
- ✅ 守护线程确保JVM可以正常退出
- ✅ 未捕获异常被正确处理和记录

### 2. 资源保护 ✅
- ✅ 应用程序关闭时自动清理仿真资源
- ✅ 线程池优雅关闭机制
- ✅ 强制关闭保护机制

### 3. 稳定性提升 ✅
- ✅ 单个仿真失败不影响其他仿真
- ✅ 服务可以在仿真异常后继续正常运行
- ✅ 完善的错误处理和日志记录

### 4. 监控能力 ✅
- ✅ 实时健康状态检查
- ✅ 详细的仿真状态跟踪
- ✅ 异常情况及时发现和处理

## 使用示例

### 1. 健康检查
```bash
curl http://localhost:9527/api/simulation/health
```

**响应示例**:
```json
{
  "success": true,
  "message": "服务健康",
  "data": {
    "isHealthy": true,
    "runningSimulations": 2,
    "activeExperiments": 2,
    "threadPoolActive": true,
    "threadPoolTerminated": false,
    "simulationDetails": {
      "123": "RUNNING",
      "124": "COMPLETED"
    }
  }
}
```

### 2. 安全停止仿真
```bash
curl -X POST http://localhost:9527/api/simulation/stop/123
```

### 3. 监控日志
```
2025-01-20 10:30:00 INFO  - 仿真开始运行 run_id=123, 线程: Simulation-123
2025-01-20 10:30:05 INFO  - 仿真运行时间: 5 秒 (run_id=123)
2025-01-20 10:30:10 ERROR - 仿真运行异常 run_id=123: Connection refused
2025-01-20 10:30:10 INFO  - 仿真线程清理完成 run_id=123
2025-01-20 10:30:10 ERROR - 仿真执行失败，但不影响后端服务继续运行 run_id=123
```

## 验证方法

### 1. 异常容错测试
1. 启动仿真
2. 外部强制关闭仿真进程
3. 验证后端服务仍然正常运行
4. 检查健康状态接口

### 2. 资源清理测试
1. 启动多个仿真
2. 正常关闭应用程序
3. 验证所有仿真被正确停止
4. 检查线程和资源是否正确清理

### 3. 并发稳定性测试
1. 并发启动多个仿真
2. 随机停止部分仿真
3. 验证其他仿真不受影响
4. 检查服务整体稳定性

## 技术特点

### 1. 防御性编程
- 多层异常处理机制
- 资源清理保证机制
- 状态一致性保护

### 2. 优雅降级
- 单个仿真失败不影响整体服务
- 资源不足时的保护机制
- 异常情况下的服务恢复

### 3. 可观测性
- 详细的日志记录
- 实时状态监控
- 健康检查机制

### 4. 可维护性
- 清晰的错误处理流程
- 统一的资源管理
- 标准化的状态管理

## 总结

通过实施线程隔离、异常处理、资源管理和健康监控等多层防护机制，成功解决了仿真线程关闭导致后端停止的问题。

**关键改进**:
- ✅ 守护线程池确保线程隔离
- ✅ 多层异常处理防止异常传播
- ✅ JVM关闭钩子保证资源清理
- ✅ 健康监控机制提供可观测性

**效果**:
- ✅ 后端服务稳定性显著提升
- ✅ 仿真异常不再影响主服务
- ✅ 资源管理更加完善
- ✅ 问题排查能力增强

这个修复方案不仅解决了当前问题，还为系统的长期稳定运行提供了坚实的基础。
